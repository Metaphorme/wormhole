# Wormhole

一个安全、易用、高性能的文本与文件传输通道。

## 安装方法

### 编译安装

1. 安装 [Go](https://go.dev/) 编译器

2. 编译 wormhole

    ```bash
    go build ./cmd/wormhole         # 编译客户端
    go build ./cmd/wormhole-server  # 编译中心服务器（普通用户不需要）
    ```

3. 测试

    ```bash
    go test ./...
    ```

## 使用方法

### 客户端

1. 发起连接

   在设备 A 上执行：

    ```bash
    wormhole
    ```

   会得到类似这样的输出：

    ```
    Your PeerID: 12D3KooWJZQCkVyttfh9bouZsPpzu1m14wAoVawMCXbaq4QiWTZz
    Starting session…
    Your code: 250-semicolon-turtle
    Ask peer to run: wormhole -c 250-semicolon-turtle
    (Expires: 2025-09-07 20:50:59)
    waiting for peer…
    ```

    在设备 B 执行：

    ```bash
    wormhole -c 250-semicolon-turtle
    ```

    之后，设备 A 会显示：

    ```
    ┌─ Peer Verification ───────────────────────────────────────┐
    ID  : 12D3KooWT349yUGxCDeDavKEK997f2Dp2CuEj7fRw8zpTW6MzU9h
    SAS : 🐼 🍪 ⛰️ 🎲 🍫
    └───────────────────────────────────────────────────────────┘
    2025-09-07 20:51:07 Confirm peer within 30s [y/N]:
    ```

    设备 B 会显示：

    ```
    Your PeerID: 12D3KooWT349yUGxCDeDavKEK997f2Dp2CuEj7fRw8zpTW6MzU9h
    ┌─ Peer Verification ───────────────────────────────────────┐
    ID  : 12D3KooWJZQCkVyttfh9bouZsPpzu1m14wAoVawMCXbaq4QiWTZz
    SAS : 🐼 🍪 ⛰️ 🎲 🍫
    └───────────────────────────────────────────────────────────┘
    2025-09-07 20:51:07 Waiting for peer confirmation…
    2025-09-07 20:51:07 Verify peer locally within 30s [y/N]:
    ```

    > **⚠️ 警告：请务必仔细核对对方的 Peer ID 或 SAS，并使用其他安全的通讯方式告知对方，以确保连接到正确的设备。**

    输入 `y` 以接受连接，你会看到：

    ```
    ┌─ Connection Summary ──────────────────────────────┐
    path   : DIRECT (quic-v1)
    local  : /ip6/::/udp/38263/quic-v1
    remote : /ip6/::1/udp/58630/quic-v1
    └───────────────────────────────────────────────────┘
    Commands:
    /peer                  show peer id & current path
    /send -f <file>        send a file
    /send -d <dir>         send a directory recursively
    /bye                   close the chat
    connected. type message to chat, or a command starting with '/'.
    >  
    ```

    你可以直接输入文本信息，按回车后传输给对方。或者使用 `/send` 命令传输单个文件或文件夹。

### 中心服务器的建立

Wormhole 客户端已内置官方提供的免费中心服务器，因此普通用户无需自建中心服务器。如果用户有特殊需求需要部署自己的中心服务器，可以遵循指南进行部署。

首先，编译并执行 `wormhole-server`。首次执行将生成 `server.key`（服务器身份密钥文件）和 `wormhole.db` （存储状态的数据库）。请仔细查看输出，确保服务端获取了正确的、客户可访问IP的 IP 地址（此 IP 将下发到客户端），否则，请指定 `public-addrs`。

之后，可以通过以下命令启动服务端：

```
wormhole-server \
  -db ./wormhole.db \
  -identity ./server.key \
  -control-listen :8000 \
  -listen "/ip4/0.0.0.0/tcp/4001,/ip4/0.0.0.0/udp/4001/quic-v1,/ip4/0.0.0.0/tcp/4002/ws" \
  -public-addrs "/ip4/<客户可访问IP>/tcp/4001,/ip4/<客户可访问IP>/udp/4001/quic-v1,/ip4/<客户可访问IP>/tcp/4002/ws"
```

如需启用 SSL，请使用 `caddy` 或其他工具对 control-listen 的端口进行反向代理并启用 SSL。

## 技术细节

### 传输策略

#### 建立连接的过程

**流程概述：**

* **Host 端发码**：Host 端首先向控制面申请一个一次性 `nameplate`，包含一对短口令，然后通过该口令生成完整的连接代码。Host 打印出代码供 Connect 端输入。
* **Connect 端认领**：Connect 端输入代码并通过控制面请求 `claim` 操作，成功后获得 rendezvous 地址、relay 地址和 topic 等信息。
* **P2P 连接的建立**：Connect 端和 Host 端尝试通过 libp2p 网络建立直接的 P2P 连接，如果直连不可行（如 NAT 问题），则会回退到通过中继进行转发。
* **传输路径选择**：根据网络状况、对端的地址信息、是否提供可用中继等因素，动态选择直连或中继转发。如果对端有中继地址或使用静态中继，则会经过 relay 进行中转，避免 NAT 防火墙问题。
* **连接握手与安全性**：连接成功后，双方使用 **PAKE** 协议进行安全握手，通过短口令+双方 PeerID + 协议 ID + nameplate 进行共享密钥协商，从而确保通信的安全性。

**设计优势：**

* **灵活性**：在实际的网络环境中，P2P 连接并不总是可行，特别是在 NAT 网络中。通过先尝试 P2P 连接，确保尽可能地减少延迟和带宽消耗。如果无法直连，回退到中继则确保了即使在受限的网络环境下，也能建立稳定连接。
* **安全性**：通过 P2P 网络建立的连接可以直接通过加密流进行数据传输，保证传输内容不被中间人窃听或篡改。而且即使使用中继，所有传输的数据都依然会经过端到端的加密，避免了中继服务器的泄密风险。
* **隐私保护**：通过在建立连接时提供 topic 和控制面信息，并依靠 libp2p 加密机制，使得中继和中心服务器无法直接访问通信内容，即使它们在网络中转发数据。

#### 传输方式：P2P 优先，失败后回退到中继

**传输策略：**

* **尽可能使用 P2P**：连接建立时，优先尝试直接的 P2P 连接。P2P 的优势在于：

  * **低延迟和高带宽**：点对点的直接连接避免了通过中继转发的延迟和带宽损耗。
  * **去中心化**：直接的 P2P 连接减少了对中心服务器的依赖，提高了系统的可用性和抗审查能力。
  * **隐私保护**：P2P 连接时，数据不经过中心服务器或中继节点，确保传输过程中的隐私性。

* **回退到中继**：在 P2P 连接失败时（例如由于 NAT 防火墙或对端未提供中继服务），连接会回退到通过 relay 进行中转。

  * **中继的作用**：relay 的存在是为了确保在网络条件不理想时，通信双方仍然能够通过中继进行数据交换。通过 libp2p 的 `p2p-circuit` 协议，连接会通过一个中继节点转发数据，使得即使对端不可达，通信仍然能够进行。

**设计优势：**

* **可扩展性和可靠性**：通过 P2P 连接能够大幅提升网络的性能和吞吐量，但在网络条件不佳时（如两端都在 NAT 后），回退到中继机制确保了系统的可靠性。即使在一些极端的网络条件下，wormhole 也能保证连接的成功率。
* **灵活性**：如果对端没有公开的 P2P 地址或者 NAT 难以穿透，中继机制可以提供中转功能，确保连接的稳定性。在保证 P2P 高效通信的同时，也保证了对复杂网络环境的兼容性。
* **去中心化和隐私保护**：即使使用中继，所有的通信内容依然是加密的，中继节点无法解密数据，确保了通信的隐私性。而且因为中继可以是去中心化的，避免了中心化系统的单点故障问题。

### 底层协议：libp2p + SPAKE2 + HMAC + Noise/TLS

**底层传输协议设计：**

* **libp2p**：libp2p 是 wormhole 采用的基础协议栈，支持 P2P 网络的构建与连接。libp2p 为每个连接提供加密的通道和多种传输方式（如 TCP、UDP、WebSocket、QUIC）。在 wormhole 中，libp2p 使得 P2P 连接成为可能，并且提供了 NAT 穿透、加密传输和多路复用等功能。
* **SPAKE2**：用于密钥协商的协议，通过短口令与双方 PeerID 等信息生成共享密钥。这确保了通信双方的身份验证，并且通过 HMAC 和 SAS (Short Authentication String) 进一步验证双方身份。
* **HMAC**：用于确认双方共享密钥的有效性，在握手过程中，双方通过 HMAC 验证交换的数据是否被篡改，从而防止中间人攻击。
* **Noise/TLS**：传输层使用 Noise 协议（基于 TLS）来加密连接，确保数据的机密性和完整性。Noise 协议在 libp2p 中被用作加密握手和加密传输的基础。

**设计优势：**

* **安全性**：libp2p 和 SPAKE2 的结合确保了即使短口令被攻击者知道，攻击者也无法在没有握手过程的情况下解密通信。HMAC 和 SAS 提供了额外的安全层，确保了通信双方的身份认证。
* **高效性**：libp2p 不仅支持多种传输方式，还提供了 NAT 穿透技术，能够使得即使双方在 NAT 后也能建立连接。而且 libp2p 在传输过程中支持多路复用，进一步提升了连接效率。
* **抗篡改和抗中间人攻击**：使用 SPAKE2 和 HMAC 结合加密流确保了数据传输的完整性与安全性，防止中间人攻击、篡改或重放攻击。

#### 总结

* **效率**：优先采用 P2P 连接，能够提供较低的延迟和高带宽。即使 P2P 连接不可用，通过中继进行中转也能确保通信稳定性，避免了完全依赖中心服务器的单点故障风险。
* **安全性**：采用 PAKE + SPAKE2 的密钥协商方式，结合 HMAC 验证机制和 Noise/TLS 加密协议，确保了传输的机密性、完整性和身份验证的安全性。无论是 P2P 连接还是中继转发，通信内容始终是加密的，防止中间人攻击和数据篡改。
* **隐私保护**：数据传输始终保持端到端加密，即使经过中继服务器也无法被解密，确保了通信内容的私密性。控制面只负责协调连接，不直接参与数据传输，进一步降低了数据泄露的风险。
* **灵活性和可扩展性**：P2P 优先保证了高效连接，而回退到中继则确保了在复杂网络环境下的可靠连接。libp2p 提供的多传输协议与 NAT 穿透功能，使得 wormhole 在各种网络环境下都能够高效运行。

### 安全性

#### 安全认证流程（PAKE + 人在环核对）

* 双方在已建立的 libp2p 加密流上，先交换 `##HELLO`，随后进行 **SPAKE2** 密钥协商，协商材料包含 nameplate、协议ID、以及按字典序排序的双方 PeerID，拼成唯一的 transcript。PAKE 产出共享密钥 `K`。
* 为防主动攻击（MITM），双方从 `K` 经 HKDF 派生确认密钥 `Kc`，互发 HMAC 标签并校验，不通过即中止。
* 再从 `K` 生成 5 个 emoji 组成的 **SAS（短认证字符串）**，显示给用户进行人工比对，30 秒内互发 `##ACCEPT/##REJECT` 完成“人在环”确认。

PAKE 让弱口令（短码中的两词口令）只用于认证，不被离线穷举；HMAC 确认绑定到 transcript，阻断中间人；SAS 的人工比对是对“真实对等方”的最终确认，避免“看起来连上了其实是错误的人”的风险。

#### 一次性代码（nameplate + 两词口令）

* Host 端向控制面申请 **一次性数字 nameplate**（3–4 位，带 TTL），成功分配后打印给用户，并本地随机两词生成口令，组合成完整代码 `<nameplate>-<word>-<word>`。
* Connect 端用代码去 **claim** 其中一侧（host/connect），两侧都成功认领才进入配对；若无此记录/已过期/已消费，服务器统一回复 `failed`，且为避免“探测是否存在”，会把 `expires_at` 伪装成“现在”。
* nameplate 分配要避冲突且只在“未过期、未消费”时可用，失败会重试；会话达成后客户端上报 `consume` 将其标记为已用。

代码短时有效+一次性消费，把在线猜码的时间/次数窗口压小；服务器端“存在性隐藏”防止外部枚举有效 nameplate；两端必须都认领才能进入会面，减少撞库骚扰面。

#### 端到端加密（传输层 E2E）

* 真实数据（聊天/传文件）走 libp2p 加密连接；服务器侧显式启用 **Noise 与 TLS** 安全传输，客户端默认 libp2p 也建立加密会话；即使经 **circuit relay v2** 走中继，双方仍是端到端加密，**中继/中心服务器看不到明文**。

libp2p 的加密握手在两个对等节点之间完成，任何经手的第三方（包括 rendezvous 与 relay）都只转发密文。

#### 前向保密（PFS）

* libp2p 的 Noise 会为每次连接生成新会话密钥，旧会话密钥泄露不影响历史会话机密性（PFS）。PAKE 的 `K` 亦是**每会话新鲜**的协商结果，并不会被持久化使用。

攻击者即使事后拿到短码或某次会话的密钥材料，也无法解开以前的会话内容。

#### 完整性与抗篡改

* 文件传输额外做了端到端完整性校验：从 `K` + 传输协议 transcript 派生出 **XXH3-128 的种子**，接收端对每个文件计算哈希并与发送端声明的期望值比对，不匹配则删除文件并告知用户。

哈希的种子与握手密钥绑定，第三方伪造/替换内容无法通过校验；即使传输层已加密，这层完整性仍可侦测意外或对端缺陷导致的数据损坏。

#### 最小信任与抗滥用

* 控制面只管 “allocate/claim/consume/fail” 与返回 rendezvous/relay/topic，不参与密钥协商，更**看不到两词口令**；并对请求与失败做 IP 维度速率限制，过量立即 429 并给出等待时间。

即便控制面或中继被攻陷，也拿不到会话明文或握手密钥；限流+短 TTL 限制在线猜测/枚举的有效性。
